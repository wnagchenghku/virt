ExoKernel

看上去，内核已经被研究人员们研究地没得玩了。但ExoKernel又是另外一种内核，跟前面的几种都有不同。而且ExoKernel的风格，感觉上跟Xen，kvm这样的VMM有很大程度的相似，包括某些部分的实现，比如内存管理上。

之前说到的Monolithic Kernel也好，Micro Kernel也好，它们对资源的保护和管理都是在内核里去做的，也就是说，它们都是先对硬件做抽象，然后向上不直接暴露硬件，而是暴露硬件的抽象。一个例子，硬盘是硬件设备，但是我们的应用程序看到的是一个个的文件，文件本身就是一种抽象。而应用程序，是没办法直接操作硬件的，只能跟操作系统提供的抽象打交道。

那这样无疑是使得写应用的程序员不需要关心硬件，但是对于一些应用而言，其实是不好的。有一部分应用，就是需要跟硬件直接打交道。课上夏老师举的例子，是说数据库，MySQL，特别希望自己能够直接跟磁盘来交互，这样可以精确地确定它的索引等等文件的存储位置，来针对硬件来做优化。

那这样的需求，之前的内核都是没办法满足的。于是，ExoKernel就被提了出来。Exokernel的设计思路是尽可能减少抽象层次，允许应用程序直接访问硬件，而ExoKernel只负责保护和分配系统资源。应用程序过来请求资源，Exokernel看看资源是否空闲，如果空闲，直接交给应用，至于应用怎么访问是它自己的事。

ExoKernel分离了对硬件的使用和保护，使得应用程序可以直接使用没有经过Kernel抽象的硬件，就很好很强大。但是这样又有了其他的问题，那如果一个应用想发个HTTP请求，总不能先自己实现一套网络栈吧。于是，LibOS的概念就出现了

至于实现，其实有很多地方跟Xen很像，比如说都会用Software-defined TLB来做内存控制，就是在Flush TLB后，触发TLB Miss就会trap到ExoKernel，这个时候会先检查合法性，然后再填适当的缓存项到TLB中。要是没有Software-defined TLB就用页表来做。LibOS只能读，不能写自己的页表，所有对页表的写，都会trap到ExoKernel，然后ExoKernel会在这次trap中做检查，跟Software-defined TLB差不多，只是在不同层次的实现，但实现方式都是trap的方式。等等，还有很多地方。

所谓LibOS，全称是Library Operation System。LibOS提供对于硬件的抽象，与用户代码编译成一个二进制，在同一地址空间。而且LibOS可以修改定制，来适配上层用户对硬件的具体需求，如控制物理内存的相邻等等。

UniKernel

Unikernel是一种LibOS，它有着自己的哲学，那就是一个操作系统应该只有一个进程，内核和应用都在一个地址空间内(其最大的卖点就是在，没有用户空间与内核空间之分，只有一个连续的地址空间。这样使得 Unikernel 中只能运行一个应用，而且对于运行的应用而言，没有硬件抽象可言，所有的逻辑，包括应用逻辑和操作硬件的逻辑，都在一个地址空间中)。这样的好处就是，可以使得这个操作系统，或者说应用，非常地快。因为操作系统所有的资源都是这个应用的，而且所有对象都在一个地址空间里。还安全，相当于是可以剪裁原本的Monolithic Kernel，抛弃掉不用的功能，只把需要的硬件抽象Library编译到二进制里面。

有这么多好处，不是它火的关键，最关键的是云计算的流行。Unikernel可以直接运行在Xen上，而且不像传统OS那样，它小，而且安全，还快，简直就是天生为云计算而生的。从某种程度而言，是云计算中理想的Guest OS。

不过它也有一个广受诟病的缺点，就是没办法调试，不过我觉得这个倒不是关键，因为在开发的时候可以不用UniKernel，而在生产环境中再编译出UniKernel再去部署。还有就是硬件支持比较困难，会导致Library的碎片化，这个问题还挺严重的，就像安卓一样，不知道有没有解。